/* tslint:disable */
/* eslint-disable */
/*
Catalog API

This API lists data sets available on Agrimetrics platform.

The version of the OpenAPI document: 


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { fromBuffer } from "file-type/browser"
const FormData = require("form-data")
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { DataRequest } from '../models';
// @ts-ignore
import { DataRequestCreateSingleAccessRequestResponse } from '../models';
// @ts-ignore
import { DataRequestDetailsInner } from '../models';
// @ts-ignore
import { DataRequestGetResults406Response } from '../models';
// @ts-ignore
import { DataRequestResponseInner } from '../models';
// @ts-ignore
import { DataRequestUpdateRequestRequest } from '../models';
// @ts-ignore
import { DataRequestUpdateRequestResponse } from '../models';
// @ts-ignore
import { GeoJSONPolygon } from '../models';
// @ts-ignore
import { RestError } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * DataRequestApi - axios parameter creator
 * @export
 */
export const DataRequestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a single access request for an authenticated user
         * @summary create a single access request
         * @param {string} projectName The name of the project the data is for
         * @param {string} projectManagerName The name of the project manager who can approve the request
         * @param {string} projectManagerEmail The email address of the project manager who can approve the request
         * @param {string} datasetId The ID of the dataset that the data request relates to
         * @param {string} datasetName The name of the dataset that the data request relates to
         * @param {string} requestedFormat The format the user would like the data to be provided in
         * @param {string} [geoJsonAOI] The area of interest that the user is requesting access to as a stringified GeoJSON
         * @param {Uint8Array | File | buffer.File} [shapefileAOI] The area of interest that the user is requesting access to as a zipped shapefile
         * @param {DataRequest} [dataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSingleAccessRequest: async (projectName: string, projectManagerName: string, projectManagerEmail: string, datasetId: string, datasetName: string, requestedFormat: string, geoJsonAOI?: string, shapefileAOI?: Uint8Array | File | buffer.File, dataRequest?: DataRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('createSingleAccessRequest', 'projectName', projectName)
            // verify required parameter 'projectManagerName' is not null or undefined
            assertParamExists('createSingleAccessRequest', 'projectManagerName', projectManagerName)
            // verify required parameter 'projectManagerEmail' is not null or undefined
            assertParamExists('createSingleAccessRequest', 'projectManagerEmail', projectManagerEmail)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('createSingleAccessRequest', 'datasetId', datasetId)
            // verify required parameter 'datasetName' is not null or undefined
            assertParamExists('createSingleAccessRequest', 'datasetName', datasetName)
            // verify required parameter 'requestedFormat' is not null or undefined
            assertParamExists('createSingleAccessRequest', 'requestedFormat', requestedFormat)
            const localVarPath = `/data-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (projectName !== undefined) {
                await addFormParam('projectName', projectName, false, true)
            }
    
            if (projectManagerName !== undefined) {
                await addFormParam('projectManagerName', projectManagerName, false, true)
            }
    
            if (projectManagerEmail !== undefined) {
                await addFormParam('projectManagerEmail', projectManagerEmail, false, true)
            }
    
            if (datasetId !== undefined) {
                await addFormParam('datasetId', datasetId, false, true)
            }
    
            if (datasetName !== undefined) {
                await addFormParam('datasetName', datasetName, false, true)
            }
    
            if (geoJsonAOI !== undefined) {
                await addFormParam('geoJsonAOI', geoJsonAOI, false, true)
            }
    
            if (shapefileAOI !== undefined) {
                await addFormParam('shapefileAOI', shapefileAOI, true, true)
            }
    
            if (requestedFormat !== undefined) {
                await addFormParam('requestedFormat', requestedFormat, false, true)
            }
    
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: dataRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/data-requests',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the geometry of the data request as GeoJSON
         * @summary Get geometry for data request as GeoJSON
         * @param {string} uniqueLinkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeoJsonGeometry: async (uniqueLinkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uniqueLinkId' is not null or undefined
            assertParamExists('getGeoJsonGeometry', 'uniqueLinkId', uniqueLinkId)
            const localVarPath = `/data-requests/{uniqueLinkId}/geometry`
                .replace(`{${"uniqueLinkId"}}`, encodeURIComponent(String(uniqueLinkId !== undefined ? uniqueLinkId : `-uniqueLinkId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/data-requests/{uniqueLinkId}/geometry',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the users requested data
         * @summary gets the data for the approved request
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRequestedData: async (requestId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestId' is not null or undefined
            assertParamExists('getRequestedData', 'requestId', requestId)
            const localVarPath = `/data-requests/{requestId}`
                .replace(`{${"requestId"}}`, encodeURIComponent(String(requestId !== undefined ? requestId : `-requestId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/data-requests/{requestId}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Once a data access request has been approved, this endpoint returns the data requested.
         * @summary Get the results of your data request
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResults: async (requestId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestId' is not null or undefined
            assertParamExists('getResults', 'requestId', requestId)
            const localVarPath = `/data-requests/{requestId}/download`
                .replace(`{${"requestId"}}`, encodeURIComponent(String(requestId !== undefined ? requestId : `-requestId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/data-requests/{requestId}/download',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Grants access to a user on a given data request
         * @summary approve data access
         * @param {string} uniqueLinkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantUserAccess: async (uniqueLinkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uniqueLinkId' is not null or undefined
            assertParamExists('grantUserAccess', 'uniqueLinkId', uniqueLinkId)
            const localVarPath = `/data-requests/{uniqueLinkId}/approve`
                .replace(`{${"uniqueLinkId"}}`, encodeURIComponent(String(uniqueLinkId !== undefined ? uniqueLinkId : `-uniqueLinkId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/data-requests/{uniqueLinkId}/approve',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query the given users data access requests 
         * @summary lists a users data requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserAccessRequests: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/data-requests',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rejects access to a user on a given data request
         * @summary reject data access
         * @param {string} uniqueLinkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectUserAccess: async (uniqueLinkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uniqueLinkId' is not null or undefined
            assertParamExists('rejectUserAccess', 'uniqueLinkId', uniqueLinkId)
            const localVarPath = `/data-requests/{uniqueLinkId}/reject`
                .replace(`{${"uniqueLinkId"}}`, encodeURIComponent(String(uniqueLinkId !== undefined ? uniqueLinkId : `-uniqueLinkId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/data-requests/{uniqueLinkId}/reject',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows updating of the given data request | - For example: cancelling the request 
         * @summary updates a data request
         * @param {string} requestId 
         * @param {DataRequestUpdateRequestRequest} [dataRequestUpdateRequestRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRequest: async (requestId: string, dataRequestUpdateRequestRequest?: DataRequestUpdateRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestId' is not null or undefined
            assertParamExists('updateRequest', 'requestId', requestId)
            const localVarPath = `/data-requests/{requestId}`
                .replace(`{${"requestId"}}`, encodeURIComponent(String(requestId !== undefined ? requestId : `-requestId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: dataRequestUpdateRequestRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/data-requests/{requestId}',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(dataRequestUpdateRequestRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataRequestApi - functional programming interface
 * @export
 */
export const DataRequestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DataRequestApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a single access request for an authenticated user
         * @summary create a single access request
         * @param {DataRequestApiCreateSingleAccessRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSingleAccessRequest(requestParameters: DataRequestApiCreateSingleAccessRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataRequestCreateSingleAccessRequestResponse>> {
            const dataRequest: DataRequest = {
                projectName: requestParameters.projectName,
                projectManagerName: requestParameters.projectManagerName,
                projectManagerEmail: requestParameters.projectManagerEmail,
                datasetId: requestParameters.datasetId,
                datasetName: requestParameters.datasetName,
                geoJsonAOI: requestParameters.geoJsonAOI,
                shapefileAOI: requestParameters.shapefileAOI,
                requestedFormat: requestParameters.requestedFormat
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSingleAccessRequest(requestParameters.projectName, requestParameters.projectManagerName, requestParameters.projectManagerEmail, requestParameters.datasetId, requestParameters.datasetName, requestParameters.requestedFormat, requestParameters.geoJsonAOI, requestParameters.shapefileAOI, dataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the geometry of the data request as GeoJSON
         * @summary Get geometry for data request as GeoJSON
         * @param {DataRequestApiGetGeoJsonGeometryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGeoJsonGeometry(requestParameters: DataRequestApiGetGeoJsonGeometryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeoJSONPolygon>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGeoJsonGeometry(requestParameters.uniqueLinkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the users requested data
         * @summary gets the data for the approved request
         * @param {DataRequestApiGetRequestedDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRequestedData(requestParameters: DataRequestApiGetRequestedDataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataRequestDetailsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRequestedData(requestParameters.requestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Once a data access request has been approved, this endpoint returns the data requested.
         * @summary Get the results of your data request
         * @param {DataRequestApiGetResultsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResults(requestParameters: DataRequestApiGetResultsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Uint8Array | File | buffer.File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResults(requestParameters.requestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Grants access to a user on a given data request
         * @summary approve data access
         * @param {DataRequestApiGrantUserAccessRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async grantUserAccess(requestParameters: DataRequestApiGrantUserAccessRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.grantUserAccess(requestParameters.uniqueLinkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Query the given users data access requests 
         * @summary lists a users data requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserAccessRequests(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataRequestResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserAccessRequests(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Rejects access to a user on a given data request
         * @summary reject data access
         * @param {DataRequestApiRejectUserAccessRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectUserAccess(requestParameters: DataRequestApiRejectUserAccessRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectUserAccess(requestParameters.uniqueLinkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Allows updating of the given data request | - For example: cancelling the request 
         * @summary updates a data request
         * @param {DataRequestApiUpdateRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRequest(requestParameters: DataRequestApiUpdateRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataRequestUpdateRequestResponse>> {
            const dataRequestUpdateRequestRequest: DataRequestUpdateRequestRequest = {
                status: requestParameters.status
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRequest(requestParameters.requestId, dataRequestUpdateRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DataRequestApi - factory interface
 * @export
 */
export const DataRequestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DataRequestApiFp(configuration)
    return {
        /**
         * Create a single access request for an authenticated user
         * @summary create a single access request
         * @param {DataRequestApiCreateSingleAccessRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSingleAccessRequest(requestParameters: DataRequestApiCreateSingleAccessRequestRequest, options?: AxiosRequestConfig): AxiosPromise<DataRequestCreateSingleAccessRequestResponse> {
            return localVarFp.createSingleAccessRequest(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the geometry of the data request as GeoJSON
         * @summary Get geometry for data request as GeoJSON
         * @param {DataRequestApiGetGeoJsonGeometryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeoJsonGeometry(requestParameters: DataRequestApiGetGeoJsonGeometryRequest, options?: AxiosRequestConfig): AxiosPromise<GeoJSONPolygon> {
            return localVarFp.getGeoJsonGeometry(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the users requested data
         * @summary gets the data for the approved request
         * @param {DataRequestApiGetRequestedDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRequestedData(requestParameters: DataRequestApiGetRequestedDataRequest, options?: AxiosRequestConfig): AxiosPromise<Array<DataRequestDetailsInner>> {
            return localVarFp.getRequestedData(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Once a data access request has been approved, this endpoint returns the data requested.
         * @summary Get the results of your data request
         * @param {DataRequestApiGetResultsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResults(requestParameters: DataRequestApiGetResultsRequest, options?: AxiosRequestConfig): AxiosPromise<Uint8Array | File | buffer.File> {
            return localVarFp.getResults(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Grants access to a user on a given data request
         * @summary approve data access
         * @param {DataRequestApiGrantUserAccessRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantUserAccess(requestParameters: DataRequestApiGrantUserAccessRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.grantUserAccess(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Query the given users data access requests 
         * @summary lists a users data requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserAccessRequests(options?: AxiosRequestConfig): AxiosPromise<Array<DataRequestResponseInner>> {
            return localVarFp.listUserAccessRequests(options).then((request) => request(axios, basePath));
        },
        /**
         * Rejects access to a user on a given data request
         * @summary reject data access
         * @param {DataRequestApiRejectUserAccessRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectUserAccess(requestParameters: DataRequestApiRejectUserAccessRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rejectUserAccess(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows updating of the given data request | - For example: cancelling the request 
         * @summary updates a data request
         * @param {DataRequestApiUpdateRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRequest(requestParameters: DataRequestApiUpdateRequestRequest, options?: AxiosRequestConfig): AxiosPromise<DataRequestUpdateRequestResponse> {
            return localVarFp.updateRequest(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createSingleAccessRequest operation in DataRequestApi.
 * @export
 * @interface DataRequestApiCreateSingleAccessRequestRequest
 */
export type DataRequestApiCreateSingleAccessRequestRequest = {
    
    /**
    * The name of the project the data is for
    * @type {string}
    * @memberof DataRequestApiCreateSingleAccessRequest
    */
    readonly projectName: string
    
    /**
    * The name of the project manager who can approve the request
    * @type {string}
    * @memberof DataRequestApiCreateSingleAccessRequest
    */
    readonly projectManagerName: string
    
    /**
    * The email address of the project manager who can approve the request
    * @type {string}
    * @memberof DataRequestApiCreateSingleAccessRequest
    */
    readonly projectManagerEmail: string
    
    /**
    * The ID of the dataset that the data request relates to
    * @type {string}
    * @memberof DataRequestApiCreateSingleAccessRequest
    */
    readonly datasetId: string
    
    /**
    * The name of the dataset that the data request relates to
    * @type {string}
    * @memberof DataRequestApiCreateSingleAccessRequest
    */
    readonly datasetName: string
    
    /**
    * The format the user would like the data to be provided in
    * @type {string}
    * @memberof DataRequestApiCreateSingleAccessRequest
    */
    readonly requestedFormat: string
    
    /**
    * The area of interest that the user is requesting access to as a stringified GeoJSON
    * @type {string}
    * @memberof DataRequestApiCreateSingleAccessRequest
    */
    readonly geoJsonAOI?: string
    
    /**
    * The area of interest that the user is requesting access to as a zipped shapefile
    * @type {Uint8Array | File | buffer.File}
    * @memberof DataRequestApiCreateSingleAccessRequest
    */
    readonly shapefileAOI?: Uint8Array | File | buffer.File
    
} & DataRequest

/**
 * Request parameters for getGeoJsonGeometry operation in DataRequestApi.
 * @export
 * @interface DataRequestApiGetGeoJsonGeometryRequest
 */
export type DataRequestApiGetGeoJsonGeometryRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof DataRequestApiGetGeoJsonGeometry
    */
    readonly uniqueLinkId: string
    
}

/**
 * Request parameters for getRequestedData operation in DataRequestApi.
 * @export
 * @interface DataRequestApiGetRequestedDataRequest
 */
export type DataRequestApiGetRequestedDataRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof DataRequestApiGetRequestedData
    */
    readonly requestId: string
    
}

/**
 * Request parameters for getResults operation in DataRequestApi.
 * @export
 * @interface DataRequestApiGetResultsRequest
 */
export type DataRequestApiGetResultsRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof DataRequestApiGetResults
    */
    readonly requestId: string
    
}

/**
 * Request parameters for grantUserAccess operation in DataRequestApi.
 * @export
 * @interface DataRequestApiGrantUserAccessRequest
 */
export type DataRequestApiGrantUserAccessRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof DataRequestApiGrantUserAccess
    */
    readonly uniqueLinkId: string
    
}

/**
 * Request parameters for rejectUserAccess operation in DataRequestApi.
 * @export
 * @interface DataRequestApiRejectUserAccessRequest
 */
export type DataRequestApiRejectUserAccessRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof DataRequestApiRejectUserAccess
    */
    readonly uniqueLinkId: string
    
}

/**
 * Request parameters for updateRequest operation in DataRequestApi.
 * @export
 * @interface DataRequestApiUpdateRequestRequest
 */
export type DataRequestApiUpdateRequestRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof DataRequestApiUpdateRequest
    */
    readonly requestId: string
    
} & DataRequestUpdateRequestRequest

/**
 * DataRequestApiGenerated - object-oriented interface
 * @export
 * @class DataRequestApiGenerated
 * @extends {BaseAPI}
 */
export class DataRequestApiGenerated extends BaseAPI {
    /**
     * Create a single access request for an authenticated user
     * @summary create a single access request
     * @param {DataRequestApiCreateSingleAccessRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataRequestApiGenerated
     */
    public createSingleAccessRequest(requestParameters: DataRequestApiCreateSingleAccessRequestRequest, options?: AxiosRequestConfig) {
        return DataRequestApiFp(this.configuration).createSingleAccessRequest(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the geometry of the data request as GeoJSON
     * @summary Get geometry for data request as GeoJSON
     * @param {DataRequestApiGetGeoJsonGeometryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataRequestApiGenerated
     */
    public getGeoJsonGeometry(requestParameters: DataRequestApiGetGeoJsonGeometryRequest, options?: AxiosRequestConfig) {
        return DataRequestApiFp(this.configuration).getGeoJsonGeometry(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the users requested data
     * @summary gets the data for the approved request
     * @param {DataRequestApiGetRequestedDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataRequestApiGenerated
     */
    public getRequestedData(requestParameters: DataRequestApiGetRequestedDataRequest, options?: AxiosRequestConfig) {
        return DataRequestApiFp(this.configuration).getRequestedData(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Once a data access request has been approved, this endpoint returns the data requested.
     * @summary Get the results of your data request
     * @param {DataRequestApiGetResultsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataRequestApiGenerated
     */
    public getResults(requestParameters: DataRequestApiGetResultsRequest, options?: AxiosRequestConfig) {
        return DataRequestApiFp(this.configuration).getResults(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Grants access to a user on a given data request
     * @summary approve data access
     * @param {DataRequestApiGrantUserAccessRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataRequestApiGenerated
     */
    public grantUserAccess(requestParameters: DataRequestApiGrantUserAccessRequest, options?: AxiosRequestConfig) {
        return DataRequestApiFp(this.configuration).grantUserAccess(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query the given users data access requests 
     * @summary lists a users data requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataRequestApiGenerated
     */
    public listUserAccessRequests(options?: AxiosRequestConfig) {
        return DataRequestApiFp(this.configuration).listUserAccessRequests(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Rejects access to a user on a given data request
     * @summary reject data access
     * @param {DataRequestApiRejectUserAccessRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataRequestApiGenerated
     */
    public rejectUserAccess(requestParameters: DataRequestApiRejectUserAccessRequest, options?: AxiosRequestConfig) {
        return DataRequestApiFp(this.configuration).rejectUserAccess(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows updating of the given data request | - For example: cancelling the request 
     * @summary updates a data request
     * @param {DataRequestApiUpdateRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataRequestApiGenerated
     */
    public updateRequest(requestParameters: DataRequestApiUpdateRequestRequest, options?: AxiosRequestConfig) {
        return DataRequestApiFp(this.configuration).updateRequest(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
